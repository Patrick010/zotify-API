#!/usr/bin/env python3
import json
import yaml
from pathlib import Path
import os

TRACE_INDEX_PATH = Path("project/reports/TRACE_INDEX.yml")
OUTPUT_JSON = Path("scripts/project_registry.json")
OUTPUT_MD = Path("project/PROJECT_REGISTRY.md")

# This map is the authoritative source for document descriptions.
METADATA_MAP = {
    "project/ALIGNMENT_MATRIX.md": "Maps strategic goals to design documents, implementation, and documentation.",
    "project/BACKLOG.md": "A prioritized list of approved, actionable tasks for future development.",
    "project/CICD.md": "High-level overview of the CI/CD pipeline and its quality gates for stakeholders.",
    "project/DEPENDENCIES.md": "Outlines the policy and approval process for adding new third-party dependencies.",
    "project/EXECUTION_PLAN.md": "Detailed task breakdown for each phase of the project, aligned with the roadmap.",
    "project/FUTURE_ENHANCEMENTS.md": "A living document capturing long-term product vision and feature ideas.",
    "project/HIGH_LEVEL_DESIGN.md": "Outlines the high-level architecture, layers, and non-functional requirements for the Zotify API platform.",
    "project/LESSONS-LEARNT.md": "A log of key takeaways and lessons learned during each project phase.",
    "project/LOGGING_PHASES.md": "Authoritative tracker for the phased design and implementation of the Extendable Logging System.",
    "project/LOGGING_SYSTEM_DESIGN.md": "Technical design document for the centralized, extendable logging system.",
    "project/LOGGING_TRACEABILITY_MATRIX.md": "Maps logging requirements to design artifacts and implementation tasks.",
    "project/LOW_LEVEL_DESIGN.md": "Provides detailed, low-level design specifications for key architectural components.",
    "project/ONBOARDING.md": "A guide for new developers to get up to speed on the project's context and procedures.",
    "project/PID.md": "Defines the project's business case, strategic goals, scope, and governance controls.",
    "project/PROJECT_BRIEF.md": "A high-level, one-page summary of the project's objectives, scope, and deliverables.",
    "project/PROJECT_PLAN.md": "A central, execution-oriented plan for developers, synthesized from the roadmap and PID.",
    "project/PROJECT_REGISTRY.md": "The master index for all project-level documentation, auto-generated by the build script.",
    "project/QA_GOVERNANCE.md": "Defines the project's quality assurance policies and the linter rules that enforce them.",
    "project/ROADMAP.md": "Provides a high-level, strategic overview of the project's major development phases.",
    "project/SECURITY.md": "Outlines the platform's security philosophy, details implemented features, and tracks future security enhancements.",
    "project/TASK_CHECKLIST.md": "A mandatory quality gate checklist for all development work before completion.",
    "project/USECASES.md": "Defines target user scenarios and primary use cases for the Zotify platform.",
    "project/USECASES_GAP_ANALYSIS.md": "Analyzes current feature coverage against defined use cases to identify development opportunities.",
    "project/logs/ACTIVITY.md": "A chronological log of all major tasks and significant actions completed.",
    "project/logs/CURRENT_STATE.md": "A snapshot of the project's current status, known issues, and next steps.",
    "project/logs/SESSION_LOG.md": "A detailed log of activities, findings, and outcomes from each development session.",
    "project/process/GAP_ANALYSIS_TEMPLATE.md": "A standardized template for performing and documenting gap analysis.",
    "project/proposals/DBSTUDIO_PLUGIN.md": "Proposal for a modular, backend-agnostic database browser plugin.",
    "project/proposals/DYNAMIC_PLUGIN_PROPOSAL.md": "Proposal for a dynamic plugin system for custom components like logging sinks.",
    "project/proposals/GONKUI_PLUGIN.md": "Proposal to convert the GonkUI testing tool into a dynamic, installable plugin.",
    "project/proposals/GOVERNANCE_AUDIT_REFACTOR.md": "Proposal to refactor the governance script into a comprehensive, automated audit system.",
    "project/proposals/HOME_AUTOMATION_PROPOSAL.md": "Proposal for integrating with home automation platforms like Home Assistant.",
    "project/proposals/LOW_CODE_PROPOSAL.md": "Proposal for integrating with low-code/no-code platforms like Node-RED.",
    "project/proposals/MULTI_SOURCE_METADATA_PROPOSAL.md": "Proposal for a plugin-driven system to manage metadata from multiple sources.",
    "project/proposals/NEW_PROPOSAL.md": "A template for creating new project proposals.",
    "project/proposals/QA_GATE_IMPLEMENTATION_PLAN.md": "A phased implementation plan for the new QA Gate system.",
    "project/proposals/TRACE_INDEX_SCHEMA_ADAPTATION.md": "Proposal to adapt the TRACE_INDEX.yml schema for improved uniformity.",
    "project/proposals/TRACE_INDEX_SCHEMA_FIX.md": "Proposal to fix the TRACE_INDEX.yml schema for improved precision.",
    "project/reports/GOVERNANCE_DEMO_REPORT.md": "A demonstration report showcasing the functionality of the governance audit script.",
    "project/reports/HANDOVER_BRIEF_CHATGTP.md": "A handover brief created for a previous AI assistant.",
    "project/reports/HANDOVER_BRIEF_JULES.md": "A handover brief created by Jules for the next developer.",
    "project/reports/PROJECT_AUDIT_FINAL_REPORT.md": "The final report concluding the comprehensive project-wide audit and governance refactoring.",
    "project/reports/PROJECT_DOCUMENT_ALIGNMENT.md": "A report documenting the alignment of project documents.",
}

def normalize_path(path_str: str) -> str:
    """Normalize file paths to a consistent form."""
    norm = Path(path_str).as_posix().strip()
    while norm.startswith("./") or norm.startswith("../"):
        norm = norm.split("/", 1)[-1]
    return norm

def load_trace_index():
    """Load TRACE_INDEX.yml and return its entries."""
    with open(TRACE_INDEX_PATH, "r", encoding="utf-8") as f:
        data = yaml.safe_load(f)
    artifacts = data.get("artifacts", [])
    if not isinstance(artifacts, list):
        raise ValueError("TRACE_INDEX.yml 'artifacts' key must contain a list")
    return {item.get('path', ''): item for item in artifacts}

def build_project_registry(trace_index):
    """Generate registry entries for all project markdown files."""
    registry = {}
    unclassified = []

    for path_str, info in trace_index.items():
        norm = normalize_path(path_str)
        if not norm.startswith("project/") or not norm.endswith(".md"):
            continue
        if "logs/" in norm or "tests/" in norm:
            continue

        description = METADATA_MAP.get(norm)
        if not description:
            description = f"TODO: Add description for {Path(norm).name}"
            unclassified.append(norm)

        status = "registered"
        if not Path(norm).exists():
            status = "missing"

        registry[norm] = {
            "path": norm,
            "status": status,
            "description": description,
        }

    if unclassified:
        print("⚠️ Warning: The following files need proper descriptions in METADATA_MAP:")
        for p in sorted(unclassified):
            print(f"  - {p}")

    unique_registry = {k: v for k, v in sorted(registry.items())}
    if len(unique_registry) < len(registry):
        print(f"⚠️ Removed {len(registry) - len(unique_registry)} duplicate entries")

    return unique_registry

def write_json(registry):
    OUTPUT_JSON.parent.mkdir(parents=True, exist_ok=True)
    with open(OUTPUT_JSON, "w", encoding="utf-8") as f:
        json.dump(list(registry.values()), f, indent=2)
    print(f"✅ Wrote {len(registry)} entries to {OUTPUT_JSON}")

def write_markdown(registry):
    OUTPUT_MD.parent.mkdir(parents=True, exist_ok=True)
    lines = [
        "# Project Registry\n",
        "",
        "| Path | Status | Description |",
        "|------|---------|-------------|",
    ]
    for item in registry.values():
        lines.append(f"| `{item['path']}` | {item['status']} | {item['description']} |")
    OUTPUT_MD.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"✅ Wrote markdown summary to {OUTPUT_MD}")

def main():
    trace_index = load_trace_index()
    registry = build_project_registry(trace_index)
    write_json(registry)
    write_markdown(registry)

if __name__ == "__main__":
    main()